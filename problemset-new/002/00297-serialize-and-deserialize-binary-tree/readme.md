# 297. Serialize and Deserialize Binary Tree


背景：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。


题意：设计一个算法来实现二叉树的序列化与反序列化。  


思路： 


假设这棵树是标准的二叉树，那直接按照先序遍历的方法就可以生成一个可逆的序列。  


大概方法有一个队列，代表当前构造出来树的叶子节点。  
每次从队列里得到待处理的节点`A`，序列里面接下来的两个值就是节点`A`的两个儿子。  
然后两个儿子进入队列，这样队列就保持了所描述的包含所有叶子节点的性质。  


![](http://res.tiankonguse.com/images/2019/05/23/001.png)  


例如上面这个满的二叉树。  

起始条件是构造的树只有根，队列里的叶子也是根`[1]`，序列列表是剩余的节点`[2,3,4,5,6,7]`  

则模拟过程如下：  


```
第一步  
队列： [1]
序列： [2,3,4,5,6,7]

第二步
队列： [2,3]
序列： [4,5,6,7]

第三步
队列： [3,4,5]
序列： [6,7]  

第四步
队列： [4,5,6,7]
序列： []

后序发现序列为空，代表这些是真正的叶子节点。  
```

而对于非标准二叉树，有些节点可能只有一个儿子，此时可以使用 `null` 来代替。  
扫描的时候，遇到`null`特殊处理即可。  


![](http://res.tiankonguse.com/images/2019/05/22/001.png)  


比如对于上面的非标准二叉树，对应的序列化可以表示为`[3,9,20,null,null,15,7]`。  


模拟过程如下：  


```
第一步  
队列： [3]
序列： [9,20,null,null,15,7]

第二步
队列： [9,20]
序列： [null,null,15,7]

第三步
队列： [20]
序列： [15,7]  

第四步
队列： [15,7]
序列： []

后序发现序列为空，代表这些是真正的叶子节点。  
```

其中关键步骤在于第三步：发现节点`9`的两个儿子都是`null`时,我们没有进行入队操作。  
这样后面的序列就可以正常的构造出二叉树了。  


总结一下就是：当一个节点某个儿子为空时，用`null`代替。这样使用先序遍历生成的序列就可以唯一的标示一个二叉树了。  


而对于二叉树生成序列，而按照定义`BFS`生成即可。  










