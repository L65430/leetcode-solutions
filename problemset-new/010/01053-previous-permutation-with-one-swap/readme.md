# 1053. Previous Permutation With One Swap  


题意：给一个数列`A`，求选两个位置进行交换一次，使得新得到的数列字典序小于`A`，且是最大的数列。  


思路：求小于字典序且最大，那交换的两个位置就需要尽可能的靠后。  


由于是求小于字典中的序列，只需要从后到前，找到第一个非递减的序列。  
如`b[i] > b[i+1] <= b[i+2] <= ... <= b[n]`。   
如果`i`不存在，则说明整个数列就是最小的，返回原数列即可。  


否则在`b[i+1] ~ b[n]`里面挑一个小于 `b[i]`的数字进行交换。  


具体来说，由于为了使答案最大，也就是应该使`b[i]`最大，这里需要挑小于`b[i]`的最大数字。  


根据`Example 4`的数据可以知道，如果小于`b[i]`的最大数字有多个时，使用最后一个交换。  
由此，这道题就做出来了。  


## C++语言  

[1053-tiankonguse.cpp](./1053-tiankonguse.cpp)

