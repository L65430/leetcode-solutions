## 1040. Moving Stones Until Consecutive II


题意：给一些互不相同的数字，每次可以将最大的数字或者最小的数字进行修改。修改后这个值不能是最大值和最小值。  
最终不能移动时，结束。  
求移动的最大步数和最小步数。  


思路：对于最大步数，肯定是最好一步步的移动。  
由于规则的限制，第一次移动可能不是一步，而是很多步，之后可以一步步移动。  
所以第一次移动时，选择步数最小的（最大值和最小值两个数字选一个），之后就是有多少个空位置，就可以移到多少次。  


而对于最小步数，则是尽可能所有数字只移动一次。
做题的时候，我的思路是暴利枚举。  
假设数字最终区间确定，那么移动的最小步数也是确定的。  
枚举所有可能的区间，然后计算最小步数。  


这道题最优答案是贪心计算。  
假设找到了最长的连续数字，则其他数字都应该移到到这个最大的连续数字附近。  
需要移动的步数就是不是最长连续数字的个数。  
但是有一个特殊情况：连续数字是`n-1`个且最小值或最大值不是连续数字，此时需要两步，而不是一步。


## C++  


[tiankonguse.cpp](./tiankonguse.cpp)





